/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.zookeeper.server.quorum;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.apache.jute.BinaryInputArchive;
import org.apache.jute.InputArchive;
import org.apache.log4j.Logger;
import org.apache.zookeeper.server.NIOServerCnxn;
import org.apache.zookeeper.server.ZooKeeperServer;
import org.apache.zookeeper.txn.TxnHeader;

/**
 * This class manages the quorum protocol. There are three states this server
 * can be in:
 * <ol>
 * <li>Leader election - each server will elect a leader (proposing itself as a
 * leader initially).</li>
 * <li>Follower - the server will synchronize with the leader and replicate any
 * transactions.</li>
 * <li>Leader - the server will process requests and forward them to followers.
 * A majority of followers must log the request before it can be accepted.
 * </ol>
 *
 * This class will setup a datagram socket that will always respond with its
 * view of the current leader. The response will take the form of:
 *
 * <pre>
 * int xid;
 *
 * long myid;
 *
 * long leader_id;
 *
 * long leader_zxid;
 * </pre>
 *
 * The request for the current leader will consist solely of an xid: int xid;
 */
public class QuorumPeer extends Thread implements QuorumStats.Provider {
    private static final Logger LOG = Logger.getLogger(QuorumPeer.class);

    /**
     * Create an instance of a quorum peer
     */
    public interface Factory{
        public QuorumPeer create(NIOServerCnxn.Factory cnxnFactory) throws IOException;
        public NIOServerCnxn.Factory createConnectionFactory() throws IOException;
    }

    public static class QuorumServer {
        public QuorumServer(long id, InetSocketAddress addr) {
            this.id = id;
            this.addr = addr;
        }

        public InetSocketAddress addr;

        public long id;
    }

    public enum ServerState {
        LOOKING, FOLLOWING, LEADING;
    }
    /**
     * The servers that make up the cluster
     */
    ArrayList<QuorumServer> quorumPeers;
    public int getQuorumSize(){
        return quorumPeers.size();
    }
    /**
     * My id
     */
    private long myid;


    /**
     * get the id of this quorum peer.
     */
    public long getId() {
        return myid;
    }

    /**
     * This is who I think the leader currently is.
     */
    volatile Vote currentVote;

    volatile boolean running = true;

    /**
     * The number of milliseconds of each tick
     */
    int tickTime;

    /**
     * The number of ticks that the initial synchronization phase can take
     */
    int initLimit;

    /**
     * The number of ticks that can pass between sending a request and getting
     * an acknowledgement
     */
    int syncLimit;

    /**
     * The current tick
     */
    int tick;

    /**
     * This class simply responds to requests for the current leader of this
     * node.
     * <p>
     * The request contains just an xid generated by the requestor.
     * <p>
     * The response has the xid, the id of this server, the id of the leader,
     * and the zxid of the leader.
     *
     * @author breed
     *
     */
    class ResponderThread extends Thread {
        ResponderThread() {
            super("ResponderThread");
        }

        public void run() {
            try {
                byte b[] = new byte[36];
                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
                DatagramPacket packet = new DatagramPacket(b, b.length);
                while (true) {
                    udpSocket.receive(packet);
                    if (packet.getLength() != 4) {
                        LOG.warn("Got more than just an xid! Len = "
                                + packet.getLength());
                    } else {
                        responseBuffer.clear();
                        responseBuffer.getInt(); // Skip the xid
                        responseBuffer.putLong(myid);
                        switch (state) {
                        case LOOKING:
                            responseBuffer.putLong(currentVote.id);
                            responseBuffer.putLong(currentVote.zxid);
                            break;
                        case LEADING:
                            responseBuffer.putLong(myid);
                            try {
                                responseBuffer.putLong(leader.lastProposed);
                            } catch (NullPointerException npe) {
                                // This can happen in state transitions,
                                // just ignore the request
                            }
                            break;
                        case FOLLOWING:
                            responseBuffer.putLong(currentVote.id);
                            try {
                                responseBuffer.putLong(follower.getZxid());
                            } catch (NullPointerException npe) {
                                // This can happen in state transitions,
                                // just ignore the request
                            }
                        }
                        packet.setData(b);
                        udpSocket.send(packet);
                    }
                    packet.setLength(b.length);
                }
            } catch (Exception e) {
                LOG.warn("Unexpected exception",e);
            } finally {
                LOG.warn("QuorumPeer responder thread exited");
            }
        }
    }

    private ServerState state = ServerState.LOOKING;

    public void setPeerState(ServerState newState){
        state=newState;
    }

    public ServerState getPeerState(){
        return state;
    }

    DatagramSocket udpSocket;

    private InetSocketAddress myQuorumAddr;

    public InetSocketAddress getQuorumAddress(){
        return myQuorumAddr;
    }

    /**
     * the directory where the snapshot is stored.
     */
    private File dataDir;

    /**
     * the directory where the logs are stored.
     */
    private File dataLogDir;

    private int electionType;

    Election electionAlg;

    int electionPort;

    NIOServerCnxn.Factory cnxnFactory;


    public QuorumPeer() {
        super("QuorumPeer");
    }
    
    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
            File dataLogDir, int electionType, int electionPort,long myid, int tickTime,
            int initLimit, int syncLimit,NIOServerCnxn.Factory cnxnFactory) throws IOException {
        this();
        this.electionType = electionType;
        this.cnxnFactory = cnxnFactory;
        this.quorumPeers = quorumPeers;
        this.dataDir = dataDir;
        this.electionPort = electionPort;
        this.dataLogDir = dataLogDir;
        this.myid = myid;
        this.tickTime = tickTime;
        this.initLimit = initLimit;
        this.syncLimit = syncLimit;        
        
        QuorumStats.getInstance().setStatsProvider(this);
    }

    @Override
    public synchronized void start() {
        
        currentVote = new Vote(myid, getLastLoggedZxid());
        for (QuorumServer p : quorumPeers) {
            if (p.id == myid) {
                myQuorumAddr = p.addr;
                break;
            }
        }
        if (myQuorumAddr == null) {
            throw new RuntimeException("My id " + myid + " not in the peer list");
        }
        if (electionType == 0) {
            try {
                udpSocket = new DatagramSocket(myQuorumAddr.getPort());
                new ResponderThread().start();
            } catch (SocketException e) {
                new RuntimeException(e);
            }
        }
        this.electionAlg = createElectionAlgorithm(electionType);
        super.start();
    }
    
    /**
     * This constructor is only used by the existing unit test code.
     */
    public QuorumPeer(ArrayList<QuorumServer> quorumPeers, File dataDir,
            File dataLogDir, int clientPort, int electionAlg, int electionPort,
            long myid, int tickTime, int initLimit, int syncLimit) throws IOException {
        this(quorumPeers,dataDir,dataLogDir,electionAlg,electionPort,myid,tickTime,
                initLimit,syncLimit,new NIOServerCnxn.Factory(clientPort));
    }

    public Follower follower;
    public Leader leader;

    private int clientPort;

    protected Follower makeFollower(File dataDir,File dataLogDir) throws IOException {
        FollowerZooKeeperServer zks = new FollowerZooKeeperServer(dataDir, dataLogDir, this,new ZooKeeperServer.BasicDataTreeBuilder());
        zks.setClientPort(clientPort);
        return new Follower(this, zks);
    }

    protected Leader makeLeader(File dataDir,File dataLogDir) throws IOException {
        LeaderZooKeeperServer zks = new LeaderZooKeeperServer(dataDir, dataLogDir,
                this,new ZooKeeperServer.BasicDataTreeBuilder());
        zks.setClientPort(clientPort);
        return new Leader(this, zks);
    }

    private Election createElectionAlgorithm(int electionAlgorithm){
        Election le=null;
        //TODO: use a factory rather than a switch
        switch (electionAlgorithm) {
        case 0:
            // will create a new instance for each run of the protocol
            break;
        case 1:
            le = new AuthFastLeaderElection(this, this.electionPort);
            break;
        case 2:
            le = new AuthFastLeaderElection(this, this.electionPort, true);
            break;
        case 3:
            le = new FastLeaderElection(this,
                        new QuorumCnxManager(this.electionPort));
        default:
            assert false;
        }
        return le;
    }

    protected Election makeLEStrategy(){
        if(electionAlg==null)
            return new LeaderElection(this);
        return electionAlg;
    }

    synchronized protected void setLeader(Leader newLeader){
        leader=newLeader;
    }

    synchronized protected void setFollower(Follower newFollower){
        follower=newFollower;
    }

    synchronized public ZooKeeperServer getActiveServer(){
        if(leader!=null)
            return leader.zk;
        else if(follower!=null)
            return follower.zk;
        return null;
    }

    public void run() {
        /*
         * Main loop
         */
        while (running) {
            switch (state) {
            case LOOKING:
                try {
                    LOG.info("LOOKING");
                    currentVote = makeLEStrategy().lookForLeader();
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e);
                    state = ServerState.LOOKING;
                }
                break;
            case FOLLOWING:
                try {
                    LOG.info("FOLLOWING");
                    setFollower(makeFollower(dataDir,dataLogDir));
                    follower.followLeader();
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e);
                } finally {
                    follower.shutdown();
                    setFollower(null);
                    state = ServerState.LOOKING;
                }
                break;
            case LEADING:
                LOG.info("LEADING");
                try {
                    setLeader(makeLeader(dataDir,dataLogDir));
                    leader.lead();
                    setLeader(null);
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e);
                } finally {
                    if (leader != null) {
                        leader.shutdown("Forcing shutdown");
                        setLeader(null);
                    }
                    state = ServerState.LOOKING;
                }
                break;
            }
        }
        LOG.warn("QuorumPeer main thread exited");
    }

    public void shutdown() {
        running = false;
        if (leader != null) {
            leader.shutdown("quorum Peer shutdown");
        }
        if (follower != null) {
            follower.shutdown();
        }
        cnxnFactory.shutdown();
        udpSocket.close();
    }

    long getLastLoggedZxid() {
        File[] list = dataLogDir.listFiles();
        if (list == null) {
            return 0;
        }
        long maxLog = -1;
        long maxSnapShot = 0;
        for (File f : list) {
            String name = f.getName();
            if (name.startsWith("log.")) {
                long zxid = ZooKeeperServer.getZxidFromName(f.getName(), "log");
                if (zxid > maxLog) {
                    maxLog = zxid;
                }
            } else if (name.startsWith("snapshot.")) {
                long zxid = ZooKeeperServer.getZxidFromName(f.getName(),
                        "snapshot");
                if (zxid > maxLog) {
                    maxSnapShot = zxid;
                }
            }
        }
        if (maxSnapShot > maxLog) {
            return maxSnapShot;
        }
        long zxid = maxLog;
        FileInputStream logStream = null;
        try {
            logStream = new FileInputStream(new File(dataLogDir, "log."
                    + Long.toHexString(maxLog)));
            BinaryInputArchive ia = BinaryInputArchive.getArchive(logStream);
            while (true) {
                byte[] bytes = ia.readBuffer("txnEntry");
                if (bytes.length == 0) {
                    // Since we preallocate, we define EOF to be an
                    // empty transaction
                    break;
                }
                int B = ia.readByte("EOR");
                if (B != 'B') {
                    break;
                }
                InputArchive bia = BinaryInputArchive
                        .getArchive(new ByteArrayInputStream(bytes));
                TxnHeader hdr = new TxnHeader();
                hdr.deserialize(bia, "hdr");
                zxid = hdr.getZxid();
            }
        } catch (IOException e) {
            LOG.warn("Unexpected exception", e);
        } finally {
            try {
                if (logStream != null) {
                    logStream.close();
                }
            } catch (IOException e) {
                LOG.warn("Unexpected exception",e);
            }
        }
        return zxid;
    }

    public String[] getQuorumPeers() {
        List<String> l = new ArrayList<String>();
        synchronized (this) {
            if (leader != null) {
                synchronized (leader.followers) {
                    for (FollowerHandler fh : leader.followers) {
                        if (fh.sock == null)
                            continue;
                        String s = fh.sock.getRemoteSocketAddress().toString();
                        if (leader.isFollowerSynced(fh))
                            s += "*";
                        l.add(s);
                    }
                }
            } else if (follower != null) {
                l.add(follower.sock.getRemoteSocketAddress().toString());
            }
        }
        return l.toArray(new String[0]);
    }

    public String getServerState() {
        switch (state) {
        case LOOKING:
            return QuorumStats.Provider.LOOKING_STATE;
        case LEADING:
            return QuorumStats.Provider.LEADING_STATE;
        case FOLLOWING:
            return QuorumStats.Provider.FOLLOWING_STATE;
        }
        return QuorumStats.Provider.UNKNOWN_STATE;
    }

    /**
     * get the id of this quorum peer.
     */
    public long getMyid() {
        return myid;
    }

    /**
     * set the id of this quorum peer.
     */
    public void setMyid(long myid) {
        this.myid = myid;
    }

    /**
     * Get the number of milliseconds of each tick
     */
    public int getTickTime() {
        return tickTime;
    }

    /**
     * Set the number of milliseconds of each tick
     */
    public void setTickTime(int tickTime) {
        this.tickTime = tickTime;
    }

    /**
     * Get the number of ticks that the initial synchronization phase can take
     */
    public int getInitLimit() {
        return initLimit;
    }

    /**
     * Set the number of ticks that the initial synchronization phase can take
     */
    public void setInitLimit(int initLimit) {
        this.initLimit = initLimit;
    }

    /**
     * Get the number of ticks that can pass between sending a request and getting
     * an acknowledgement
     */
    public int getSyncLimit() {
        return syncLimit;
    }

    /**
     * Set the number of ticks that can pass between sending a request and getting
     * an acknowledgement
     */
    public void setSyncLimit(int syncLimit) {
        this.syncLimit = syncLimit;
    }

    /**
     * Get the directory where the snapshot is stored.
     */
    public File getDataDir() {
        return dataDir;
    }

    /**
     * Set the directory where the snapshot is stored.
     */
    public void setDataDir(File dataDir) {
        this.dataDir = dataDir;
    }

    /**
     * Get the directory where the logs are stored.
     */
    public File getDataLogDir() {
        return dataLogDir;
    }

    /**
     * Set the directory where the logs are stored.
     */
    public void setDataLogDir(File dataLogDir) {
        this.dataLogDir = dataLogDir;
    }

    /**
     * Gets the election port
     */
    public int getElectionPort() {
        return electionPort;
    }

    /**
     * Gets the election type
     */
    public int getElectionType() {
        return electionType;
    }

    /**
     * Sets the election type
     */
    public void setElectionType(int electionType) {
        this.electionType = electionType;
    }

    /**
     * Sets the election port
     */
    public void setElectionPort(int electionPort) {
        this.electionPort = electionPort;
    }

    public NIOServerCnxn.Factory getCnxnFactory() {
        return cnxnFactory;
    }

    public void setCnxnFactory(NIOServerCnxn.Factory cnxnFactory) {
        this.cnxnFactory = cnxnFactory;
    }

    public void setQuorumPeers(ArrayList<QuorumServer> quorumPeers) {
        this.quorumPeers = quorumPeers;
    }

    public int getClientPort() {
        return clientPort;
    }

    public void setClientPort(int clientPort) {
        this.clientPort = clientPort;
    }

}
